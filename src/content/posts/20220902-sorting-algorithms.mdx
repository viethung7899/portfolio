---
title: Visualizing sorting algorithms
date: 2022-09-02
slug: visualizing-sorting-algoriithms
---

import SortingVisualizer from "../interactives/SortingVisualizer.svelte";
import CodeBlock from "@components/common/CodeBlock.astro";

<SortingVisualizer client:visible />

---

## Motivation

Sorting problem are classic introductory topic for any first-year computer science.
The algorithms are little bit intimidated at the first place, but they introduce a veriey
of interesting concepts to guide students to think like programmers for better problem solving.

My goal here is to create a tool to visualize sorting algorithms.
I hope a clear visualization can aid student to understand these algorithms. There are a lot of
website for visualizing algorithms. In fact, I already made a website for that purpose. Most of them
are just standalone websites. However, my challenge is to integrate the visulization within the blog post.

As mention on the [previous blog](/blogs/how-i-built-my-portfolio-with-astro),
I use the MDX format compose the blog posts.
MDX allow us to inject the JSX elements inside the markdown files.
For the implementation, I choose Svelte to embed interactivity within the blog post
because its simplicity.

---

## Features

The [visualizer](#sorting-visualizer) supports these features below

- Set the number of elements in the array (from 10 to 100 elements)
- Choose your algorithms
  - Bubble sort
  - Selection sort
  - Insertion sort
  - Merge sort
  - Quicksort
  - Heap sort
- Change the sorting speed (even when the animation is running)
- Play, pause and resume the animation

---

## Implementation

### Generator functions

Generartor functions are functions that can **stop midway** and **resume** to where it stopped.
They can be defined with the `function*` keyword.

Let's take a look a example below

<CodeBlock title="foo.js">
```js
function* foo() {
  console.log("To the foo land...");
  yield "Hello";

console.log("Welcome back...")
yield "World";

console.log("Bye bye!");
}


const fooGen = foo();
console.log(fooGen.next()) // Exit at line 3
console.log(fooGen.next()) // Exit at line 5
console.log(fooGen.next()) // Exit at line 6

```
</CodeBlock>

And here's the output

```json
To the foo land...
{ done: false, value: "Hello" }
Welcome back...
{ done: false, value: "World" }
Bye bye!
{ done: true, value: undefined }
```

When calling a generator function, it does not execute immediately, 
but rather return a special **Generator** object. 
The object has a method called `next()`, which starts the execution of
the function until reaching the `yeild` statements, then returns an object with two proprties: 
- `done`: a boolean to indicate the whether the function finish its execution
- a `value` specified after the stopping `yield` statement

Because of generator functions can pause during their execution, 
they can be a perfect tool to visualize sorting algorithms since we need the state
of the array during the sorting procedure.

### Lazy sorting functions

First, let take a look at very simple bubble sort function

<CodeBlock title="bubbleSort.ts">
```ts
function bubbleSort(arr: numbers[]) {
  const n = arr.length;
  for (let i = 0; i < n; i++) {
    let swapped = false;
    for (let j = 0; j < n - i - 1; j++) {
      // Compare and swap
      if (items[j].value > items[j + 1].value) {
        const temp = items[j];
        items[j] = items[j + 1];
        items[j + 1] = temp;
        swapped = true;
      }
    }
    if (!swapped) break;
  }
}
```
</CodeBlock>

To pause the execution, we can place a `yield` statement 
inside the nested `for` loop just before the `if` statemnent. 
By doing that, we can explore the state of arrray in every iteration.
In addition, we place another `yield` statement at the end since we also need
the final sorted array when the algorithm finishes execution.

<CodeBlock title="bubbleSort.ts">
```ts
function* bubbleSort(arr: numbers[]) {
  const n = arr.length;
  for (let i = 0; i < n; i++) {
    let swapped = false;
    for (let j = 0; j < n - i - 1; j++) {
      // Compare and swap
      yield arr;
      if (items[j].value > items[j + 1].value) {
        const temp = items[j];
        items[j] = items[j + 1];
        items[j + 1] = temp;
        swapped = true;
      }
    }
    if (!swapped) break;
  }
  yield arr;
}
```
</CodeBlock>

### Integrate with Svelte components
